import { v4 as uuidv4 } from 'uuid';
import { store } from '../../store.js';
import { analyzeUri } from '../../vision.js';
export function words(s) { return String(s || '').toLowerCase().replace(/[^a-z0-9\s]/g, ' ').split(/\s+/).filter(Boolean); }
export function scoreCaption(text, keywords) { const w = words(text); const k = (keywords || []).map(x => String(x).toLowerCase()); const count = w.length || 1; const kd = k.length ? w.filter(x => k.includes(x)).length / count : 0; const readability = Math.min(1, Math.max(0, 1 - Math.abs(14 - count) / 20)); const engagement = Math.min(1, w.filter(x => ['best', 'pro', 'ultimate', 'free', 'secret', 'how', 'wow', 'amazing'].includes(x)).length / 5); return { seoScore: Math.round(kd * 100), engagementScore: Math.round(((readability + engagement) / 2) * 100) }; }
export function scoreThumbnail(style, title, keywords) { const base = 0.5; const kw = (keywords || []).map(x => String(x).toLowerCase()); const t = words(title); const match = kw.length ? t.filter(x => kw.includes(x)).length : 0; const styleBoost = style === 'preset-1' ? 0.1 : style === 'preset-2' ? 0.12 : style === 'preset-3' ? 0.08 : 0.06; const score = Math.min(1, base + styleBoost + Math.min(0.2, match * 0.03)); return Math.round(score * 100); }
export function isUnsafeVideo(videoId) { const thumbs = Array.from(store.thumbnails.values()).filter(t => t.videoId === videoId); const caps = Array.from(store.captions.values()).filter(c => c.videoId === videoId); const badWords = ['nsfw', 'explicit', 'adult', 'violence']; const capUnsafe = caps.some(c => badWords.some(w => String(c.text || '').toLowerCase().includes(w))); const styleUnsafe = thumbs.some(t => badWords.includes(String(t.style || '').toLowerCase())); const safeSearchUnsafe = thumbs.some(t => { const ss = t.visionFeatures && t.visionFeatures.safeSearch; if (!ss)
    return false; const lvl = (x) => String(x || 'UNKNOWN'); const high = ['LIKELY', 'VERY_LIKELY']; return high.includes(lvl(ss.adult)) || high.includes(lvl(ss.violence)); }); return capUnsafe || styleUnsafe || safeSearchUnsafe; }
export function addRun(videoId, step, status, startedAt, completedAt) { const runId = uuidv4(); const run = { runId, videoId, step, status, startedAt, completedAt }; store.workflowRuns.set(runId, run); return runId; }
export function updateRun(runId, updates) { const old = store.workflowRuns.get(runId); if (!old)
    return; const run = { ...old, ...updates }; store.workflowRuns.set(runId, run); }
export function startPipeline(videoId) { const now = Date.now(); const pending = Array.from(store.workflowRuns.values()).find((r) => r.videoId === videoId && r.step === 'extracting_frames' && r.status === 'pending'); if (pending)
    updateRun(pending.runId, { status: 'completed', completedAt: now + 50 });
else
    addRun(videoId, 'extracting_frames', 'completed', now, now + 50); setTimeout(() => { const fNow = Date.now(); const count = 5; for (let i = 0; i < count; i++) {
    const id = uuidv4();
    const uri = `memory://frame/${id}`;
    const rec = { frameId: id, videoId, gcsUri: uri, createdAt: fNow + i * 10 };
    store.frames.set(id, rec);
} addRun(videoId, 'frame_extraction', 'completed', fNow, fNow + 50); const t1 = Date.now(); addRun(videoId, 'transcribing_audio', 'completed', t1, t1 + 50); setTimeout(() => { const t2 = Date.now(); const styles = ['preset-1', 'preset-2', 'preset-3', 'preset-4', 'preset-5']; styles.forEach(style => { const id = uuidv4(); const uri = `memory://frame/${id}`; const rec = { videoId, variantId: id, style, gcsUri: uri, visionFeatures: null, ctrScore: null, imageData: null, createdAt: Date.now() }; store.thumbnails.set(id, rec); }); addRun(videoId, 'generating_thumbnails', 'completed', t2, t2 + 50); setTimeout(() => { const t2b = Date.now(); const listForVision = Array.from(store.thumbnails.values()).filter((x) => x.videoId === videoId); Promise.all(listForVision.map(async (t) => { const vf = await analyzeUri(t.gcsUri); const updated = { ...t, visionFeatures: vf }; store.thumbnails.set(t.variantId, updated); })).then(() => { addRun(videoId, 'vision_analysis', 'completed', t2b, t2b + 50); const t3 = Date.now(); const video = store.videos.get(videoId) || { title: '' }; const list = Array.from(store.thumbnails.values()).filter((x) => x.videoId === videoId); const scored = list.map((t) => { const ctr = scoreThumbnail(t.style || 'custom', video.title, []); const updated = { ...t, ctrScore: ctr }; store.thumbnails.set(t.variantId, updated); return updated; }).sort((a, b) => (b.ctrScore || 0) - (a.ctrScore || 0)); const winner = scored[0]; addRun(videoId, 'scoring', 'completed', t3, t3 + 50); setTimeout(() => { const t4 = Date.now(); const v = store.videos.get(videoId); const updated = { ...v, status: 'ready' }; store.videos.set(videoId, updated); addRun(videoId, 'ready_to_review', 'completed', t4, t4 + 50); }, 150); }); }, 150); }, 150); }, 150); }
